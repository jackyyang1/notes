
django知识点完善



1.静态文件处理

	1.项目中的CSS、图片、js都是静态文件
	2.一般会将静态文件放到一个单独的目录中，以方便管理
	3.在html页面中调用时，也需要指定静态文件的路径，Django中提供了一种解析的方	式配置静态文件路径
	3.静态文件可以放在项目根目录下，也可以放在应用的目录下，由于有些静态文件在		项目中是通用的，所以推荐放在项目的根目录下，方便管理


	示例:

	1、在test5/settings.py文件中定义静态文件查找路径

		STATIC_URL = '/static/'
		STATICFILES_DIRS = [
		    os.path.join(BASE_DIR, 'static'),
		]

	2.创建模板
		第一种导入方式:(静态文件路径一般写法)
		<img src="/static/img/sg.png"/ alt='图片'>

		第二种导入方式:(使用反向解析动态导入图片,在使用前需要导入模板:)
			{%load static from staticfiles%}
			<img src="{%static 'img/djang.jpg'%}" alt="图片">


	3.在项目根目录下创建static目录，再创建img、css、js目录，在img文件中拷贝图片sg.png:


	4.创建视图

	5.配置url

	6.启动服务器
		在模板中写成固定路径，后期维护太麻烦，可以使用static标签，根据配置项生成静态文件路径，模板中图片的地址路径可修改如下：

		{%load static from staticfiles%}
		<img src="{%static "img/sg.png" %}"/>



2.中间件

	面试:中间件二次开发!

	1.Django中的中间件是一个轻量级、底层的插件系统，可以介入Django的请求和响应		处理过程，修改Django的输入或输出
	2.中间件的设计为开发者提供了一种无侵入式的开发方式，增强了Django框架的健壮	性，其它的MVC框架也有这个功能，名称为IoC
	3.Django在中间件中预置了六个方法，这六个方法的区别在于不同的阶段执行，对输入或输出进行干预，方法如下:


		1.初始化：无需任何参数，服务器响应第一个请求的时候调用一次，用于确定是否启用当前中间件
			def __init__():
   				 pass


   		2.处理请求前：在每个请求上调用，返回None或HttpResponse对象
   			def process_request(request):
   				 pass

		3.处理视图前：在每个请求上调用，返回None或HttpResponse对象

			def process_view(request, view_func, *view_args, **view_kwargs):
			    pass

		4.处理模板响应前：在每个请求上调用，返回实现了render方法的响应对象

			def process_template_response(request, response):
			    pass
		注:第四个这个函数无法被调用!!!不会打印任何东东!

		5.处理响应后：所有响应返回浏览器之前被调用，在每个请求上调用，返回HttpResponse对象

			def process_response(request, response):
			    pass

		6.异常处理：当视图抛出异常时调用，在每个请求上调用，返回一个HttpResponse对象

			def process_exception(request,exception):
			    pass



	使用示例:

		*自定义中间件:(django的二次开发!!!!)
		中间件是一个独立的python类，，可以定义这五个方法中的一个或多个，在booktest/目录下创建middleware.py文件，代码如下

		在test5/settings.py文件中，向MIDDLEWARE_CLASSES项中注册:

		注:__init__方法第一次会执行,后面不会执行


	实际应用示例

		1.定义中间件，阻止某些IP访问网站
			# 定义中间件阻止指定ip访问
			class Ipforbidden:
			    def process_request(self,request):
			    	# 先把要禁止的ip地址放在列表中,比如我的windows中的ip
			        ip_list = ['192.168.20.29']
			        # 获取用户访问地址
			        user_ip = request.META['REMOTE_ADDR']

			        if user_ip in ip_list:
			            return HttpResponse('<h1>精致访问</h1>')


		2.定义好了之后,添加到注册里

		3.服务器以下面方式打开:运行所有用户访问
		^C(py3_django) python@ubuntu:~/Desktop/pytest/test6$ python manage.py runserver 0.0.0.0:8000


		4.windows来访问虚拟机网址,会出现 '禁止访问'


		总结:阻止某些IP访问网站,原理是 阻止中间件中第一个类中的函数被调用
		 def process_request()阻止这个方法被调用

       坑:为什么我阻止不了访问!!!!!!可以了!!!
       解决:在IPforbidden中间件类中 打印user_ip,会发现ip不是在windows中ipconfig出来的,而是另外一个ip,
       		这个ip是虚拟机与windows直接通过桥接模式产生的一个开放于虚拟机的独立ip地址!



3.Admin站点

	1.内容发布的部分由网站的管理员负责查看、添加、修改、删除数据，开发这些重复的	
		功能是一件单调乏味、缺乏创造力的工作，为此，Django能够根据定义的模型		
		类自动地生成管理模块。
	2.在Django项目中默认启用Admin管理站点

	1.使用Admin站点功能
		1、创建超级管理员

		python manage.py createsuperuser
		2、注册模型类，使用前面创建的地区的模型类为例(在admin.py中注册)

		from django.contrib import admin
		from booktest.models import *

		admin.site.register(AreaInfo)

		3、通过用户名和密码登录后台界面:
			此时在站点管理里面就会出现:
				booktest:Area infos:
			点开Area infos会出现很多未命名的地区信息



	2.控制管理页展示
		类ModelAdmin可以控制模型在Admin界面中的展示方式，主要包括在列表页的展示方式、
		添加修改页的展示方式，在booktest/admin.py中，注册模型类前定义管理类AreaAdmin：

			class AreaAdmin(admin.ModelAdmin):
			    pass

		管理类有两种使用方式

		1.注册参数
		2.装饰器

		1、注册参数(推荐)

		admin.site.register(AreaInfo,AreaAdmin)
		2、装饰器

		@admin.register(AreaInfo)
		class AreaAdmin(admin.ModelAdmin):
		    pass


	3.1列表页选项
	
		1.页大小

		2.操作选项位置

		3.列表中的列

		4.将方法作为列

		5.列标题

		6.关联对象



		右侧过滤栏



		搜索栏


		中文标题



	3.2编辑页选项
		3.2.1显示字段顺序
		3.2.2分组显示

		3.2.3关联对象



	3.3重写模板(改后台管理页面上大标题信息,!)

	 	ctrl + L搜索
		1.在templates/目录下创建admin目录，

		2.打开当前虚拟环境中Django的目录，再向下找到admin的模板，目录如下:
		/home/python/.virtualenvs/py_django/lib/python3.5/site-packages/django/contrib/admin/templates/admin

		3.将需要更改文件拷贝到第一步建好的目录里，此处以base_site.html为例 

		4.编辑base_site.html文件(xx公司后台管理系统):
			'腾讯公司后台管理系统'|default:_('Django administration') }}</a></h1>

	注:重写后台管理页面模板的原理是,在template中新写的模板会覆盖原路径里的模板	


4.上传图片
	在python中进行图片操作，需要安装包PIL

		pip install Pillow==3.4.1

	在Django中上传图片包括两种方式：

		1.在管理页面admin中上传图片
		2.自定义form表单中上传图片



	4.1 admin上传图片

	4.1.1创建包含图片的模型类，将模型类的属性定义成models.ImageField类型:

		class PicTest(models.Model):
		    pic = models.ImageField(upload_to='booktest/')
		     # upload_to是在上传的图片前面加上booktest前缀,表示图片的路径!

	4.1.2打开test5/settings.py文件，设置图片保存路径 因为图片也属于静态文件，所以保存到static目录下

		MEDIA_ROOT=os.path.join(BASE_DIR,"static/media")


	4.1.3将admin中PicTest类注册:
		admin.site.register(PicTest)

	4.1.4通过后台访问:localhost:8000/admin
		找到pictest ,点击添加图片,添加成功之后就可以在你项目里static/img中找到这张图


	总结:
		1.迁移会把之前的area这个模型类也一起迁移上去,会覆盖之前的内存,所以在执行完python manage.py migrations之后,
			在迁移生成的0001_inital.py 文件中中把 第一个class areainfo的 迁移数据给删了

		2.将0001_inital.py 文件名改为其他名字,因为之前在数据库中test3中表django_migration已经有之前的0
			001_inital.py生成记录了,再生成会覆盖的,所以将其改名为0001_inital_img.py然后执行迁移python manage.py migrate! 这样
			就实现了单独迁移一个PicTest模型类

		3.执行迁移的时候(python manage.py migrate), 会出现提示,之前相同app已经迁移过其他模型类,要不要删除,此时要输入:no!
		
		4.迁移成功数据库中表格样式如下,其中id是django框架自动生成的:	

			mysql> desc booktest_pictest;
			+-------+--------------+------+-----+---------+----------------+
			| Field | Type         | Null | Key | Default | Extra          |
			+-------+--------------+------+-----+---------+----------------+
			| id    | int(11)      | NO   | PRI | NULL    | auto_increment |
			| pic   | varchar(100) | NO   |     | NULL    |                |
			+-------+--------------+------+-----+---------+----------------+

		5.存入图片之后数据库数据如下:
			mysql> select * from booktest_pictest;
			+----+---------------------+
			| id | pic                 |
			+----+---------------------+
			|  1 | booktest/django.jpg |
			+----+---------------------+
				

	注:
		1.areainfo已经有啦,迁移的时候,不能直接注销class areainfo,因为后面调用了areainfo,
		注销会报错

		2.迁移记录查询:select * from django_migrations:


	4.2 自定义上传
		1.把图片存到文件夹中
			1.定义视图

			# 导入settings.py文件
			from django.conf import settings


			#定义视图，接收图片数据，存储图片，同时讲图片的地址写入数据库
			def pic_handle(request):
			    #通过request的对象FILES属性拿到图片的数据
			    f1 = request.FILES.get('pic')

			    print(f1.name)

			    # 拼装图片的存储路径
			    fname = settings.MEDIA_ROOT + '/booktest/' +f1.name

			    # 打开并写入图片
			    with open(fname, 'wb') as pic:
			        # chunks（）方法 可以将图片数据分块，将分块的内容写入图片文件
			        for c in f1.chunks():
			            pic.write(c)

			    # 将图片的路径写入数据库
			    uppic = PicTest()
			    uppic.pic = 'booktest/' + f1.name
			    uppic.save()

			    return HttpResponse('Oj8K!')

			2.配置URL

			3.模板
				<html>
				<head>
				    <title>自定义上传图片</title>
				</head>
				<body>
				    <form method="post" action="/pic_handle/" enctype="multipart/form-data"> {#enctype后面是固定写法# }
				        {%csrf_token%}
				        <input type="file" name="pic"/><br>
				        <input type="submit" value="上传">
				    </form>
				</body>
				</html>

		2.把图片信息存到数据库mysql

			即在pic_handle方法中的:
			    # 将图片的路径写入数据库
			    uppic = PicTest()
			    uppic.pic = 'booktest/' + f1.name
			    uppic.save()



	4.3 显示图片

		1.打开booktest/views.py文件，创建视图pic_show
		# 显示上传的图片
		def pic_show(request):
		    pics = PicTest.objects.all()
		    return render(request,'booktest/pic_show.html',{'pics':pics})

		2.配置URL

		3.在templates/booktest/目录下创建模板pic_show.html

			    {% for pic in pics %}
		        {#  pic.pic中第一个pic是对象 第二个pic是属性 #}
		        <img src="/static/media/{{ pic.pic }}" alt="图片">
		    	{% endfor %}



5.分页

	Django提供了数据分页的类，这些类被定义在django/core/paginator.py中
	对象Paginator用于对列进行一页n条数据的分页运算
	对象Page用于表示第m页的数据



	Paginator对象

		方法init(列表,int)：返回分页对象，参数为列表数据，每面数据的条数
		属性count：返回对象总数
		属性num_pages：返回页面总数
		属性page_range：返回页码列表，从1开始，例如[1, 2, 3, 4]
		方法page(m)：返回Page对象，表示第m页的数据，下标以1开始



	Page对象

		调用Paginator对象的page()方法返回Page对象，不需要手动构造
		属性object_list：返回当前页对象的列表
		属性number：返回当前是第几页，从1开始
		属性paginator：当前页对应的Paginator对象
		方法has_next()：如果有下一页返回True
		方法has_previous()：如果有上一页返回True
		方法len()：返回当前页面对象的个数
		迭代页面对象：访问当前页面中的每个对象



		示例:
			拿到指定的页将其显示


		1.定义视图函数:

		# 定义视图，显示省级地区
		def pagelist(request,pindex):
		    # 获取省级地区的数据
		    sheng = AreaInfo.objects.filter(aParent__isnull=True)

		    # 通过pagenator类对省的列表数据进行分页，每页分10条
		    pagenator = Paginator(sheng,10)

		    if pindex == '':
		        pindex = 1

		    # 拿到某一页的数据
		    page = pagenator.page(int(pindex))

		    return render(request,'booktest/pagelist.html',{'page':page})	

		2.配置URL
			
		    url(r'^pagelist(\d*)$', views.pagelist),    

		3.模块:

		<head>
		    <meta charset="UTF-8">
		    <title>Title</title>

		    <style>
		        a{padding: 0 10px;}

		    </style>

		</head>
		<body>

		    <ul>
		        {# 显示每页的省级地区 #}
		        {% for p in page %}
		            <li>{{ p.atitle }}</li>
		        {% endfor %}
		    </ul>
		    <hr>
		    {# 将跳转页居中 #}
		    <p style="text-align:center; font-size: 20px;">

		    {# 判断条件：如果 上一页还有值 #}
		    {% if page.has_previous %}
		        <a href="/pagelist{{ page.number|add:-1 }}">上一页</a>
		    {# 翻到第一页的时候不能再翻页，只显示‘上一页’ #}
		    {% else %}
		        <a>上一页</a>
		    {% endif %}

		    {# 显示1.2.3.4页数列表 #}
		    {% for pindex in page.paginator.page_range%}
		        {% if pindex == page.number %}
		            {{ pindex }}
		        {% else %}
		        <a href="/pagelist{{ pindex }}">{{ pindex }}</a>
		        {% endif %}
		    {% endfor %}

		    {#  下一页 #}
		    {% if page.has_next %}
		        <a href="/pagelist{{ page.number|add:1 }}">下一页</a>
		    {# 翻页最后一页，不能再点了 #}
		    {% else %}
		        <a>下一页</a>
		    {% endif %}

		    </p>  



6.示例:省市区选择
	
	ajax可以传参数
	ajax相当于一个隐藏的浏览器,没有界面

	1.本示例讲解在Django中使用jquery的ajax进行数据交互
	2.jquery框架中提供了$.ajax、$.get、$.post方法，用于进行异步交互
		由于Django中默认使用CSRF约束，推荐使用$.get。




注:1.重新选择省的时候需要清空后面的市 和市对应的区

	2.ajax只能传键值对的纯数据,在最开始视图函数里拿数据的时候要把函数去除,
		只得到数据传过去!

	3.什么是嵌体事件?





************************************************************************






















































